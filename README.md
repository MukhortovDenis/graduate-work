# GoPostCSS

## Содержание
* [Что такое AST](#ast)
* [AST на языке CSS](#AST-and-CSS)
* [Реализация AST в GoPostCSS](#ast-and-gopostcss)
* [Установка](#installing)
  * [Установка GoPostCSS](#installing-gopostcss)
  * [Использование](#Using)
  * [Добавление плагинов](#plugins)
* [Разработка](#development)
  * [Как работает GoPostCSS](#how-it-works)
  * [Создание плагина](#writing-new-plugin)

## AST

Для начала определение AST из [Wikipedia](https://ru.wikipedia.org/wiki/Абстрактное_синтаксическое_дерево).

`Дерево абстрактного синтаксиса (ДАС) — в информатике конечное помеченное ориентированное дерево, в котором внутренние вершины сопоставлены (помечены) с операторами языка программирования, а листья — с соответствующими операндами. Таким образом, листья являются пустыми операторами и представляют только переменные и константы.`
    
Нужно понимать, что данная формулировка не является панацеей в понимании AST. Многое зависит от устройства самого языка, в одном случае AST может быть подобным, если речь идет ООП языках, то в другом будет разным, если это язык таблицы стилей и язык того же ООП. В первую очередь, AST - это концепция, по которой можно раскладывать разные сущности.

Абстрактное синтаксическое дерево представляет код в ином виде, более структурированном и иерархическим. Подобный разбор сущностей дает разные преимущества, в контексте gopostcss - позволяет автоматически добавлять, заменять и удалять куски кода без собственного участия, тем самым ускоряя выполнение задачи и уменьшая возможность допустить ошибку. AST может быть разной сложности, одно может фиксировать наличие или отсутствие пробелом и пустых линий, другие же фокусируются только на конкретных свойствах и действиях.

Важным моментном является тот факт, что каждый разработчик AST не придерживается каких-то конкретных правил, поэтому можно заметить существенную разницу между AST даже в рамках одного языка. Каждое абстрактное синтаксическое дерево делается для конкретных целей, в следствие чего могут специально допускаться неточности в определенных местах дерева.

В качестве конкретного примера советую рассмотреть [AST-Explorer](https://astexplorer.net). Там можно увидеть, как устроены разные парсеры AST на разных языках.

## AST and CSS

CSS - это таблицы стилей, в которых определяются свойства. Его подход к AST отличается в значительной степени от других языков. Классическое AST в CSS является набором правил, в которых содержаться описанные в коде свойства. Рассмотрим на стандартном теге `а`:
```
a {
  text-decoration: none;
}
```

Так как AST таблиц стилей является набором правил, то одним из этих правил будет тег `a`, а свойством является `text-decoration: none;`. 

Описать в AST подобное можно в разной степени подробности. Стандартный парсер для `postcss` не только вычленяет информацию о селекторе, но и четко указывает, как он был написан изначально, сколько пробелов от начала строки у свойств, есть ли пустые строки, на какой строке и на каком по счету символе располагается тот или иной символ. Подобный парсер не является быстродействующим, зато предоставляет широкий функционал для других разработчиков. Четкое описание правила позволяет с помощью плагинов легко менять не только суть кода, но и его оформление, что особенно важно в тех местах, где нужен строго определенный синтаксис.

## AST and GoPostCSS

GoPostCSS на данный момент поддерживает синтаксис [stylelint](https://stylelint.io), строго определенный синтаксис ускоряет обработку CSS и дает возможность разработчикам простоту написания плагинов. К примеру, допустимый синтаксис:
```
a {
  color: #fff;
}
```
Сама AST представлена в виде обьекта, содержащего токены. Подход с токенами обусловлен более быстрой обработкой документов, в отличие от другого способа, поточной обработки.

Каждый токен является сущностью, это может быть селектор, импорт, комментарий и т.д. В токене в зависимости от его вида, могут находиться различные правила(в случае, если это селектор). Каждое правило содержит свой массив свойств. Таким образом, разработчику плагина достаточно заменить правила и свойства на свои в AST, чтобы новый CSS документ уже обладал ими.

### Installing
Поддерживается Linux и MacOC.

Для корректной работы необходим Linux и одна версия плагинов и GoPostCSS. При написания плагина парсер доджен быть той же версии, что и GoPostCSS.

Версии приложения можно посмотреть во вкладке `Tags` в репозитории.
#### Installing GoPostCSS
Для установки GoPostCSS, выберите нужную версию и скачайте архив, разархивируйте его, можете добавить программу в глобальные переменные.

Для использования плагинов необходимо скачать ту же версию, что и GoPostCSS.
[Последняя версия](https://github.com/MukhortovDenis/gopostcss/tree/v1.0.3)

#### Using

Важно прописывать правильный путь для css файла, но воизбежание проблем css файл должен находиться рядом с бинарным `gopostcss`
Пример использования:
```
./gopostcss style.css -nf file.css
```
`-nf` - флаг, меняющий имя выходного файла, по стандарту будет добавляться приставка `new_`.
#### Plugins

Для добавления плагинов необходимо создать рядом бинарным исполняемым файлом папку `plugins`. Туда добавляются все плагины, которые хотите использовать.

Важно, чтобы плагин имел расширение `*.so`. Это специальное расширение для плагинов на языке Golang.

### Development

Разработка [парсера](https://github.com/MukhortovDenis/gopostcss_parser) не должна подразумевать сторонние пакеты, кроме стандартных. Это важный момент из-за которого, плагин может быть не совместим с GoPostCSS. Это значит, что версия Golang для парсера и для плагина, должна быть примерна одна(последняя версия написана на 1.17.8), так как даже стандартные пакеты притерпевают изменения.

GoPostCSS и плагина на него должны быть собраны на Linux или MacOC. Windows собирает бинарные файлы иначе, из-за чего GoPostCSS не будет работать на Linux или MacOC.

Для сборки GoPostCSS:
```
go build ./cmd gopostcss
```

Для сборки плагина:
```
go build -buildmode=plugin ./cmd plugin.so
```

#### How it works

Основой всего ялвяется [парсер](https://github.com/MukhortovDenis/gopostcss_parser). он является связующим элементом между cli и плагинами.
AST представлена в виде структуры:
```
type AST struct {
	Tokens []*Token
}

type Token struct {
	Type  string
	Name  string
	Rules []*Rule
}

type Rule []*string
```
Массив токенов, содержит информацию о типах, имени сущности и его правилах. Это достаточно, чтобы описать все в CSS.

Плагин должен работать с обьектом AST с помощью функции:
```
func Run(ast *parse.AST) error
```
Где `parse.AST` является тем самым обьектом.

#### Writing new plugin
Теперь рассмотрим написание плагина на [примере](https://github.com/MukhortovDenis/gopostcss_minimize/blob/main/minimize.go)

Это простой плагин, который убирает запятые, уменьшая код. Главным моментом здесь является нужной версии `"github.com/MukhortovDenis/gopostcss_parser"`

В go.mod:
```
require github.com/MukhortovDenis/gopostcss_parser v1.0.3
```

Весь функционал плагина должен находиться в функции `Run`, так как в Golang реализация функционала плагинов реализована через символьный поиск.
Важно тип функции соответствовал выше тому, что выше.
```
run, ok := symRun.(func(ast *parse.AST) error)
		if !ok {
			return errors.New("unexpected type from module symbol")
		}
```
В другом случае вы получите ошибку `unexpected type from module symbol`.

